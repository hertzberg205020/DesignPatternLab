# 工廠方法 ★★：基因演算法套件

## A. 背景

你在一間全台最大的電商購物網站中任職技術顧問。

由於公司今年營收十分得好，決定要擴建新產品團隊，在核心競爭力上研發技術來打造更體貼的電商購物網站，像是：

1. **商品推薦最佳化**：當使用者瀏覽商品時，為了推薦適當的商品給使用者，必須基於使用者過去的購買紀錄、瀏覽紀錄、點擊紀錄等等資訊信息，來找到最適合該使用者的商品推薦列表。
2. **工廠生產排程**：某個客戶公司生產線上需要生產多款產品，因此需要將機器和工人的時間進行排程，以便能夠盡可能地滿足客戶需求並最小化生產成本。
3. **定價策略最佳化**：購物網站需要實現價格優化功能，在保證利潤的前提下，找到最適合的價格設定方案。

...等等，還有非常多「需要最佳化」的情境。

可是隨後我們發現了一個難題，各個產品子團隊的工程師們發現他們的程式碼中竟然都**充斥著相似的邏輯**：

為了全面升級電商網站的表現，各個產品子團隊都不約而同地致力於「最佳化某種系統表現」上，於是每個團隊紛紛撰寫著大同小異的「最佳化演算法」程式碼。

公司的技術總監十分頭痛，雖說公司希望腳步越快越好，但技術總監又不希望因為工程師的躁進而寫出了大量難以維護的程式碼，於是他希望你（你身為公司的空降技術顧問）能夠想個辦法解決這個問題。

### 由於你很聰明，很快你就想到了要怎麼做了

你左思右想，不斷翻找著「最佳化演算法」的文獻，你不斷思考著：「到底該如何在最短時間內就讓各個產品子團隊共享同一份最佳化演算法基礎？」。

你決定在短期內先應用一個「堪用」但能「共用」的最佳化演算法，未來再透過某種擴充設計，允許各個開發團隊各自發展自己的最佳化演算法。

最後你終於想出了解法——最「堪用」的最佳化演算法，那就是「**基因演算法 (Genetic Algorithm)**」

先花點時間理解何謂「基因演算法」吧！這是在電腦科學中相當知名的一個演算法，順著需求科普一下吧！

## B. 基因演算法

**基因演算法**（Genetic Algorithm）是一種**最佳化演算法**（Optimization Algorithm）：

1. 基因演算法以「自然選擇」或「基因遺傳學」為比喻來命名。可以想像生物在基因遺傳的過程中，通過某種淘汰機制，最終留下針對某種表現最佳化的一代物種。基因演算法的運作方式，是藉由「優勝劣汰」的原則，透過遺傳算法不斷優化，最終得到一組最佳化解答。

2. 何謂**最佳化演算法**？最佳化演算法用於找到在「特定限制條件」下「最大化」或「最小化」某個「目標函數 (Objective Function) 」的解。

3. 一個最簡單的「**最佳化演算法**
   」適用情境例子是：想像你要去超市買東西，但是你的錢包中只有固定的金額，你該如何在「有限的預算內」盡可能地買到「最多」的物品呢？此時「預算」就是特定的限制條件，而「買到最多物品」是你的目標，或者說，「
   **買到多少物品**」是你的目標函數，而你希望能最大化這個目標函數回傳的值。

4. 基因演算法無法保證一定會找到「最佳解」，因為其演化過程採用的是隨機和機率的方法。每次執行基因演算法得到的結果都有可能不同，但是演化的時間越久，基因演算法找到的解答就有機會越接近「最佳解」。

### 基因演算法的具體運作細節

由於基因演算法是以「自然選擇」或「基因遺傳學」為比喻來命名，在基因演算法的每一個步驟中，也會大量使用比喻來描述每一個步驟。

所以為了有效理解它，你必須理解基因演算法的「每一道類比」對應的具體程式行為，以及「我們如何藉由基因演算法來解決最佳化問題」。

既然是藉由基因遺傳和優勝劣汰來尋找最佳的答案，那肯定在演算法中最重要的就是一群具備基因 (Genes) 的個體 (Individual)
了。我們會稱這一群個體為種群 (Population)。

### 1.「個體」就是「最佳化問題」的「答案」

你可以把每一個「個體」當成是一個個被提出的「答案」，基因演算法會在這一群個體中，尋找表現最好的答案作為結果。

根據不同問題，會設定不同的答案類型，也因此在設計基因演算法時，要先想清楚個體的類型：

1. 個體可能是一個整數 `int`
2. 個體可能是一個整數陣列 `int[]`
3. 個體也有可能是某個領域中的物件。

如果你想解決的問題是：「**商品推薦最佳化**」，那麼每個「個體」都是一個`List<Product>` 物件，代表所推薦的商品清單；如果你想解決的問題是：「
**工廠生產排程**」，那麼每個「個體」都是一個 `排程` **物件**。

### 2. 個體之間可以「交配」

在基因演算法中，為了能夠探索各式各樣可能表現良好的個體，演算法的其中一個步驟叫做「交配 (crossover)」，會讓表現良好的個體配對結為父母，然後期望生出「表現依然良好」的後代個體，因此「如何交配」會是基因演算法中很重要的一則學問。

所謂的交配指的就是「創造一個新的個體，新個體透過某種規則遺傳父母的基因」。

因此接著，你得定義好「到底什麼是個體的基因？」。每個個體身上都有「一序列的基因 (Genes)」，稱之為染色體 (Chromosome)。

你可以將基因視為是「**組成答案的基礎元素**」，針對不同的個體型態，會有不同適用的基因類型。舉例來說：對商品推薦清單
`List<Product>` 個體而言，它的基因就是單一一個 `Product` ；對整數陣列個體 `int[]` 而言，它的基因是一個整數 `int` ；而對一個整數個體
`int` 而言，它的基因是什麼呢？還能再往下拆解元素嗎？可以的—— `int` 的基因就是它的「二進位位元 (bits)」，在 Java 中我們可以用
`boolean` 來表示一個二進位位元 (表示 1 or 0)，也就是 int 的基因。

而我們稱「個體」的表現為「適應度 (Fitness)
」，也就是「答案」到底好不好的一個量化指標。如果個體的適應度越好，那麼在篩選過程中就越不容易被淘汰，也因此會留下來將良好的適應度遺傳給下一代。基因演算法藉由不斷篩選基因、交配和變異來在演化的過程，來逐漸找到「最好的答案」。

最後舉一個完整一點的例子，此為一道過度省略的範例，但能幫助你了解基因演算法的設計思想。在「商品推薦清單」這個情境中，假設有六種產品：\[A,
B, C, D, E, F\]，使用者喜歡的產品是A, C, E。你定義每個個體為 `List<Product>` 並且基因為 `Product`
。在基因演算法的演化中，你得到了一個種群，並且也知道了種群中每個個體的適應度：

1. \[A, B, C\] → 適應度 2
2. \[C, E\] → 適應度 2
3. \[D, E, F\] → 適應度 1
4. \[B, F\] → 適應度 0

接著透過篩選，你選擇讓適應度最好的 \[A, B, C\] 和 \[C, E\] 作為父母，並讓他們生出兩個小孩，小孩也是 `List<Product>`
，不過他的產品清單會遺傳至父母的清單，可能生出來的小孩為以下兩筆個體：

1. \[A, B, C, E\] → 適應度可能為 3
2. \[A, C, E\] → 適應度可能為 5

由於後代的基因是來自於優秀父母的基因，我們期望後代能表現得比父母更好，以上便是交配的例子。

### 基因演算法的虛擬程式碼

虛擬程式碼看起來就像這樣：

    種群 = 初始化種群()
    fun 基因演算法(種群): 個體 {
      for loop 迭代一定的次數:
        新的種群 = 基因篩選、交配、變異(種群)
      回傳最新種群中最優秀的個體
    }

不斷地做基因篩選、交配、變異這三個步驟，直到達到某個迭代次數為止，迭代次數越高，基因演化的次數越多，找到最佳解的機率也越高。

### 基因演算法的三大步驟：篩選、交配和變異

所以接下來，只要你理解「基因篩選、交配、基因變異」這三個步驟分別在做什麼，就算是有十足的理解了。

1. 篩選 **(Selection)**：優勝劣汰 從當前種群中選擇一部分個體作為下一代的父母。原則上，適應度好的個體在被選中的機率較大，以此增加下一代的基因品質。最常見的篩選策略有以下兩種：

    1. **Tournament Selection（錦標賽篩選法）**：將隨機選出的一部分個體進行比較，選擇適應度最好的個體參與下一代的交配和繁殖。
    2. **Rank Selection（排序篩選法）**：將個體根據適應度從大到小排序，然後根據每個個體的排名選取兩個個體進行交配。

    - **舉例說明：**
        1. **Tournament Selection（錦標賽篩選法）**：假設要選取 4 個個體參與下一代的交配和繁殖，可以從原有的個體中隨機選取 2
           個進行比較，再從剩下的個體中隨機選取 2 個進行比較，最後在這兩組比較中選出適應度最好的 2 個個體參與下一代的交配和繁殖。
        2. **Rank Selection（排序篩選法）**：假設有 4 個個體，其適應度分別為 50、30、80、10。則依照適應度大小排序後，編號分別為
           3、1、2、4，接著根據個體編號進行抽籤，選取 2 個個體進行交配和繁殖。
2. **交配 (Crossover)**：交配
   將選中的個體按照一定的概率進行配對。配對後，透過某種「交配」的規則來創造新的個體，目的是創造出新的個體 (Offspring)
   ，來增加種群的多樣性 (Diversity）。常見的基因交換規則包括以下三種：

    1. **一點交配 (Single-Point Crossover)**：隨機選擇一個交配點（可能是某個索引值），將兩個個體的基因在此點進行交換。
    2. **雙點交配 (Two-Point Crossover)**：隨機選擇兩個交配點，將兩個個體的基因在這兩點之間的區間進行交換。
    3. **均勻交配 (Uniform Crossover)**：隨機選擇每一個基因，有一半的機率從第一個個體繼承，有一半的機率從第二個個體繼承。

   被創造出來的後代會擁有交換過後的染色體。

    - **舉例說明**：假設配對到的兩個父母個體分別有以下染色體：

      Parent 1: `11010101`, Parent 2: `00101110`

        1. **一點交配 (Single-Point Crossover)**：

      選擇交配點為第四個基因（索引值為 3），將兩個個體在此點進行交換，得到下面的子代：

      Offspring 1: `11001110` Offspring 2: `00110101`

        1. **雙點交配 (Two-Point Crossover)**：

      選擇交配點為第二個和第七個基因（索引值為 1 和 6 ），將兩個個體在這兩點之間的區間進行交換，得到下面的子代：

      Offspring 1: `11101110` Offspring 2: `00010101`

        1. **均勻交配 (Uniform Crossover)**：

      對於每個基因，有一半的機率從第一個個體繼承，有一半的機率從第二個個體繼承。假設每個基因的機率是50%：

      Offspring 1: `11011111` Offspring 2: `00100100`

3. **變異 (Mutation)**：基因變異 將新生成的個體按照一定的概率變異，變異操作可以是隨機替換、反轉、位移等方式，目的是增加種群的多樣性。常見的變異策略有以下兩種：

    1. **隨機替換（Random Replacement）**：是指對染色體中的一個或多個基因「隨機地」替換成新的基因值。
    2. **反轉操作（Inversion Mutation）**：將染色體中的一段連續的基因反轉過來。例如，如果一段染色體的基因序列為「`001011101`
       」，反轉後就會變成「`110100010`」。
4. **重複執行第 1 至第 3 步：** 重複執行第2至第5步，直到達到終止條件，或是達到最大迭代次數 (Maximum Number of
   Iterations）等等。

5. **結果：** 執行完 1 到 4 步之後，接著你會獲得最終種群，你可以將最終種群視為是歷經非常多次競爭之後，被保留下來的一群菁英個體。此時種群中適應度最好的那位個體，就可以被當成是最佳化後的一個答案。

**_虛擬程式碼如下_**：

    public Individual geneticAlgorithm(Population population) {
        Population currentPopulation = population
    
      for (i in 1..MAXIMUM_NUMBER_OF_ITERATIONS) {
          Population parents = selection(currentPopulation) // 優勝劣汰：篩選這一代中最優秀的一群個體作為「父母」
          Population offspring = crossover(parents) // 讓這一群父母交配生下新的一代
          Population newPopulation = mutate(offspring) // 多元化：新的一代中會有基因變異：
          currentPopulation = newPopulation
                if (terminationCondition()) {
                    break;
                }
      }
    
        return findBestIndividual(currentPopulation) // 從最終種群中，取得適應度最好的個體
    }

大致了解基因演算法之後，接下來帶著這些基礎知識，你身為公司的技術顧問，準備好要來解決他們的技術發展隱患了嗎？

## C. 你收到了一份需求！！

在理解完基因演算法之後，接下來總結你收到的需求如下：

1. 你要開發一個「基因演算法套件」，你開發的這款套件能允許各個子團隊的研發工程師們，去針對他遇到的最佳化問題適用情境，來去客製化他所需的基因演算法。
2. 實作完「基因演算法套件」之後，為了測試他的易用性和正確性，你要使用自己開發的「基因演算法套件」來實現「E. 工廠生產排程」和「F.
   購物網站推薦」兩個測試情境中所需的最佳化演算法。

## D. 非功能性需求

1. 由於公司有大量的最佳化演算法客製化需求，你的基因演算法套件要有一定的客製化彈性和易用性：
    1. 在使用基因演算法套件來實作兩份測試情境需求時，套件必須能幫助你盡可能地減少重複的程式碼。或者說，你能夠透過撰寫「最少量」的程式碼，並且不需要再額外針對兩個測試情境去設計演算法的前提下，就能實現這兩份情境所需的功能。
    2. **開閉原則**：使用者能夠在完全不修改既有基因演算法套件程式碼的前提下，就能在使用你的套件來支援新的最佳化問題適用情境。
2. 基因演算法套件的「可讀性 (Readability)」要非常卓越，閱讀基因演算法套件的程式碼時，要能看到基因演算法中的領域知識（如：種群、個體、基因、基因篩選、交配、變種⋯⋯等等），套件的程式碼看起來就像是在展示優勝劣汰的過程，十分值得觀賞。

## E. 測試情境 1：工廠生產排程

1. 你在一間製造公司中任職演算法工程師，生產多款產品，需要將機器和工人的時間進行排程，以便能夠盡可能地滿足客戶需求並最小化生產成本。
2. 該公司需要生產 3 種產品：產品 A、產品 B 和產品 C，它們需要的生產時間分別為 2 小時、4 小時和 6 小時。公司有 2 台機器和 4
   名工人可供使用，每個產品都需要使用一台機器和一名工人才能生產，並且每台機器和每名工人一次只能處理一個產品，。在工廠中有充足的原料和備用零件，因此不需要考慮這些因素。公司需要在最短的時間內生產所需的產品數量，並滿足以下客戶需求：
    1. 產品 A：需要生產 100 個。
    2. 產品 B：需要生產 200 個。
    3. 產品 C：需要生產 300 個。

你必須透過基因演算法，將生產時間、機器和工人的使用進行組合，找到最佳的排程方案，以滿足客戶需求並最小化生產成本。

## F. 測試情境 2：購物網站推薦

1. 你所經營的購物網站有以下產品：
    1. 產品 1：價格 100 元，重量 2 公斤，類別 A。
    2. 產品 2：價格 200 元，重量 3 公斤，類別 A。
    3. 產品 3：價格 150 元，重量 5 公斤，類別 B。
    4. 產品 4：價格 300 元，重量 4 公斤，類別 B。
    5. 產品 5：價格 180 元，重量 6 公斤，類別 C。
    6. 產品 6：價格 250 元，重量 7 公斤，類別 C。
2. 系統會記載每個客戶對不同類別的產品的喜好度，好比你有一位客戶他的喜好度 (Preference) 如下：
    1. 類別 A：80%
    2. 類別 B：60%
    3. 類別 C：20%
3. 你必須透過基因演算法，來生成一份「購買推薦清單」：
    1. 將與現有購物清單相關的產品推薦給客戶，推薦的規則是：「根據客戶的預算 (Budget) 、購物袋的最大承載重量 (Capacity)和客戶對各類產品的喜好度，推薦一份購買清單來讓客戶能在預算和購物袋的承重下，購買越多自己喜歡的產品。」。

    2. 例如，假設客戶預算為 700 元，購物袋最大承載重量為 15 公斤，根據客戶的喜好度，基因演算法可能推薦以下購買清單：

        - 產品 1 x 2 (共 200 元，重量 4 公斤，類別 A)
        - 產品 4 x 1 (共 300 元，重量 4 公斤，類別 B)
        - 產品 5 x 1 (共 180 元，重量 6 公斤，類別 C)

       總計花費 680 元，重量為 14 公斤，符合客戶預算和購物袋的承重限制，同時也考慮了客戶的喜好度。

透過基因演算法，可以根據現有購物清單和推薦規則，生成最優的推薦清單，從而提高客戶的購買機率。
